<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="author" content="@drewkerrigan" />
        <meta name="viewport" content="width=device-width" />
        <meta http-equiv="Cache-Control" content="max-age=86400, must-revalidate" />
        <title>drew.kerrigan.io</title>
        <link rel="stylesheet" href="../css/base.min.css" type="text/css" />
        <link rel="stylesheet" href="../css/github.min.css" type="text/css" />
        <link rel="stylesheet" href="../css/octicons.css" type="text/css" />
    </head>
    <body>
        <div class="header-container">
            <header>
                <ul class="nav">
                    <!--Change the  URL here if working on an absolute domain-->
                    <li><a href="../"><span class="mega-octicon octicon-terminal" style="margin-right: 6px;"></span>drew.</a><a href="http://kerrigan.io"><span style="margin-right: 6px;"></span>kerrigan.io</a></li>
                    <li><a href="../cv"><span class="mega-octicon octicon-person" style="margin-right: 6px;"></span>About</a></li>
                </ul>
            </header>
        </div>

        <div class="container">
            <p class="meta">November 13, 2014 by by name: "Drew Kerrigan"</p>

<div class="post">
    <h1 id="custom-yokozuna-extractors">Custom Yokozuna Extractors</h1>
<p>In this post we are going to create a custom yokozuna extractor for Riak Search (version 2.x). The code and a shorter readme can be found here <a href="https://github.com/drewkerrigan/riak_sandbox/tree/master/search" class="uri">https://github.com/drewkerrigan/riak_sandbox/tree/master/search</a>. More information about yokozuna extractors can be found here: <a href="https://github.com/basho/yokozuna/blob/develop/docs/CONCEPTS.md#extractors" class="uri">https://github.com/basho/yokozuna/blob/develop/docs/CONCEPTS.md#extractors</a>.</p>
<h2 id="the-data">The Data</h2>
<p>To keep this guide simple, we are going to create a simple extractor which allows us to index the interesting pieces of an HTTP header packet.</p>
<p>Here is an example representation of an HTTP header:</p>
<pre><code>GET http://www.google.com HTTP/1.1
</code></pre>
<h2 id="yokozuna-text-extractor">Yokozuna Text Extractor</h2>
<p>Custom yokozuna extractors have a very simple interface that must be implemented (in Erlang). Here is what the pure text extractor looks like:</p>
<pre><code>-module(yz_text_extractor).
-include(&quot;yokozuna.hrl&quot;).
-compile(export_all).

extract(Value) -&gt;
    extract(Value, []).

extract(Value, Opts) -&gt;
    FieldName = field_name(Opts),
    [{FieldName, Value}].

-spec field_name(proplist()) -&gt; any().
field_name(Opts) -&gt;
    proplists:get_value(field_name, Opts, text).</code></pre>
<p>This extractor simply takes the contents of <code>Value</code> and returns a proplist with a single field name and the single value associated with that name. By default, the field name is <code>text</code>. If the following erlang snippet were run in a Riak console session:</p>
<pre><code>yz_text_extractor:extract(&quot;hello&quot;).</code></pre>
<p>The output would look something like this:</p>
<pre><code>[{text,&quot;hello&quot;}]</code></pre>
<p>That proplist is handed off to Solr, and the value <code>&quot;hello&quot;</code> would be indexed under the fieldname <code>text</code>.</p>
<h2 id="custom-binary-extractor">Custom Binary Extractor</h2>
<p>Back to our example of parsing a binary HTTP header packet; Erlang luckily comes with a standard packet decoder that happens to handle HTTP packets:</p>
<pre><code>erlang:decode_packet(http,&lt;&lt;&quot;GET http://www.google.com HTTP/1.1\n&quot;&gt;&gt;,[]).</code></pre>
<p>That snippet should return something like this:</p>
<pre><code>{ok,{http_request,'GET',
                  {absoluteURI,http,&quot;www.google.com&quot;,undefined,&quot;/&quot;},
                  {1,1}},
    &lt;&lt;&gt;&gt;}</code></pre>
<p>The relevant bits to an application that needed to search these packets are probably the Method (<code>GET</code>), the Host (<code>www.google.com</code>), and the Uri (<code>/</code>).</p>
<p>Using the text extractor as an example, our custom extractor should look similar to this if we want to index those 3 fields:</p>
<p><code>yz_httpheader_extractor.erl</code></p>
<pre><code>
-module(yz_httpheader_extractor).
-compile(export_all).

extract(Value) -&gt;
    extract(Value, []).

extract(Value, _Opts) -&gt;
    {ok,{http_request,Method,
            {absoluteURI,http,Host,undefined,Uri},
            _Version},
        _Rest} = erlang:decode_packet(http,Value,[]),

    [{method, Method}, {host, list_to_binary(Host)}, {uri, list_to_binary(Uri)}].</code></pre>
<h2 id="register-the-custom-extractor">Register the Custom Extractor</h2>
<p>Writing the extractor was simple enough, but in order for it to be utilized by Riak Search, a few steps need to be taken:</p>
<h3 id="compile-the-extractor">Compile the Extractor</h3>
<p>Firstly we’ll need to compile the extractor into a <code>beam</code> file and distribute it to a path that we can remember on each Riak node.</p>
<pre><code>erlc yz_httpheader_extractor.erl</code></pre>
<p>Move the resulting beam file to a directory like <code>/opt/beams</code></p>
<pre><code>mv yz_httpheader_extractor.beam /opt/beams/</code></pre>
<h3 id="configure-riak">Configure Riak</h3>
<p>We’ll need to tell Riak where to find the new beam file. This cannot currently be done using <code>riak.conf</code>, but there is a workaround if you create a file called <code>advanced.config</code> in the same directory as your <code>riak.conf</code></p>
<p><code>/etc/riak/advanced.config</code></p>
<pre><code>[{vm_args, [{&quot;-pa /opt/beams&quot;,&quot;&quot;}]}].</code></pre>
<p>This vm.args directive tells Riak to add <code>/opt/beams</code> to the erlang path when starting Riak up.</p>
<h3 id="register-the-extractor-in-riak">Register the Extractor in Riak</h3>
<pre><code>riak start
riak attach</code></pre>
<p>This should log into the running Riak node allowing us to run the register function in <code>yz_extractor</code>:</p>
<pre><code>(riak@127.0.0.1)1&gt; yz_extractor:register(&quot;application/httpheader&quot;, yz_httpheader_extractor).</code></pre>
<p>The register call should return the updated list of mimetype -&gt; extractor mappings. It should look something like this:</p>
<pre><code>[{default,yz_noop_extractor},
 {&quot;application/httpheader&quot;,yz_httpheader_extractor},
 {&quot;application/json&quot;,yz_json_extractor},
 {&quot;application/riak_counter&quot;,yz_dt_extractor},
 {&quot;application/riak_map&quot;,yz_dt_extractor},
 {&quot;application/riak_set&quot;,yz_dt_extractor},
 {&quot;application/xml&quot;,yz_xml_extractor},
 {&quot;text/plain&quot;,yz_text_extractor},
 {&quot;text/xml&quot;,yz_xml_extractor}]</code></pre>
<p>Now, any new documents submitted to yokozuna with the content type <code>application/httpheader</code> should be run through the new extractor.</p>
<p>The new extractor can be verified using the yokozuna <code>extract</code> endpoint:</p>
<p>Create a file called <code>testdata.bin</code></p>
<p><code>testdata.bin</code></p>
<pre><code>GET http://www.google.com HTTP/1.1
</code></pre>
<p>(Note the trailing newline at the end)</p>
<p>Now run a <code>PUT</code> to the extract endpoint:</p>
<pre><code>curl -XPUT -H 'content-type: application/httpheader' 'http://localhost:8098/search/extract' --data-binary &quot;@testdata.bin&quot;</code></pre>
<p>That curl call should return this JSON:</p>
<pre><code>{&quot;method&quot;:&quot;GET&quot;,&quot;host&quot;:&quot;www.google.com&quot;,&quot;uri&quot;:&quot;/&quot;}</code></pre>
<p>The new extractor can also be verified in the Riak console:</p>
<pre><code>(riak@127.0.0.1)1&gt; yz_extractor:run(&lt;&lt;&quot;GET http://www.google.com HTTP/1.1\n&quot;&gt;&gt;, yz_httpheader_extractor).</code></pre>
<p>Which should return</p>
<pre><code>[{method,'GET'},{host,&lt;&lt;&quot;www.google.com&quot;&gt;&gt;},{uri,&lt;&lt;&quot;/&quot;&gt;&gt;}]</code></pre>
<h2 id="index-and-search-for-the-data">Index and Search for the Data</h2>
<h3 id="create-schema">Create Schema</h3>
<p>(Based on default Yokozuna Solr Schema with our own field definitions, the default schema can be found here: <a href="https://raw.githubusercontent.com/basho/yokozuna/develop/priv/default_schema.xml" class="uri">https://raw.githubusercontent.com/basho/yokozuna/develop/priv/default_schema.xml</a>)</p>
<p>Create a <code>my_schema.xml</code> based on the default schema:</p>
<pre><code>...
&lt;field name=&quot;method&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot;/&gt;
&lt;field name=&quot;host&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot;/&gt;
&lt;field name=&quot;uri&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot;/&gt;
...</code></pre>
<p>Store the schema</p>
<pre><code>curl -XPUT &quot;http://localhost:8098/search/schema/my_schema&quot; \
  -H 'content-type:application/xml' \
  --data-binary @my_schema.xml</code></pre>
<h3 id="create-a-search-index-using-your-schema">Create a search index using your schema</h3>
<pre><code>curl -XPUT &quot;http://localhost:8098/search/index/my_index&quot; \
     -H'content-type:application/json' \
     -d'{&quot;schema&quot;:&quot;my_schema&quot;}'</code></pre>
<h3 id="create-a-bucket-type-so-that-multiple-buckets-can-share-an-index">Create a bucket type so that multiple buckets can share an index</h3>
<pre><code>riak-admin bucket-type create my_type '{&quot;props&quot;:{&quot;search_index&quot;:&quot;my_index&quot;}}'
riak-admin bucket-type activate my_type</code></pre>
<h3 id="store-some-data">Store Some Data</h3>
<p>Use the <code>testdata.bin</code> file we created earlier to write data to Riak:</p>
<pre><code>curl -XPUT \
  -H &quot;Content-Type: application/httpheader&quot; \
  --data-binary &quot;@testdata.bin&quot; \
  http://localhost:8098/types/my_type/buckets/headers/keys/google</code></pre>
<h3 id="query-the-data">Query the Data</h3>
<pre><code>curl 'http://localhost:8098/search/query/my_index?wt=json&amp;q=method:GET'</code></pre>
<p>And if everything is successful, we should see our record returned in the results!</p>
<pre><code>{
    &quot;response&quot;: {
        &quot;docs&quot;: [
            {
                &quot;_yz_id&quot;: &quot;1*my_type*headers*google*15&quot;,
                &quot;_yz_rb&quot;: &quot;headers&quot;,
                &quot;_yz_rk&quot;: &quot;google&quot;,
                &quot;_yz_rt&quot;: &quot;my_type&quot;,
                &quot;host&quot;: &quot;www.google.com&quot;,
                &quot;method&quot;: &quot;GET&quot;,
                &quot;uri&quot;: &quot;/&quot;
            }
        ],
        &quot;maxScore&quot;: 0.71231794,
        &quot;numFound&quot;: 1,
        &quot;start&quot;: 0
    },
    &quot;responseHeader&quot;: {
        &quot;QTime&quot;: 8,
        &quot;params&quot;: {
            &quot;127.0.0.1:8093&quot;: &quot;_yz_pn:64 OR (_yz_pn:61 AND (_yz_fpn:61)) OR _yz_pn:60 OR _yz_pn:57 OR _yz_pn:54 OR _yz_pn:51 OR _yz_pn:48 OR _yz_pn:45 OR _yz_pn:42 OR _yz_pn:39 OR _yz_pn:36 OR _yz_pn:33 OR _yz_pn:30 OR _yz_pn:27 OR _yz_pn:24 OR _yz_pn:21 OR _yz_pn:18 OR _yz_pn:15 OR _yz_pn:12 OR _yz_pn:9 OR _yz_pn:6 OR _yz_pn:3&quot;,
            &quot;q&quot;: &quot;method:GET&quot;,
            &quot;shards&quot;: &quot;127.0.0.1:8093/internal_solr/my_index&quot;,
            &quot;wt&quot;: &quot;json&quot;
        },
        &quot;status&quot;: 0
    }
}</code></pre>
</div>

        </div>
    </body>

    <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
         (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

     ga('create', 'UA-57872143-1', 'auto');
     ga('send', 'pageview');

    </script>
</html>
