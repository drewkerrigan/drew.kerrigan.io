<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="author" content="@drewkerrigan" />
        <meta name="viewport" content="width=device-width" />
        <meta http-equiv="Cache-Control" content="max-age=86400, must-revalidate" />
        <title>drew.kerrigan.io</title>
        <link rel="stylesheet" href="../css/base.min.css" type="text/css" />
        <link rel="stylesheet" href="../css/github.min.css" type="text/css" />
        <link rel="stylesheet" href="../css/octicons.css" type="text/css" />
    </head>
    <body>
        <div class="header-container">
            <header>
                <ul class="nav">
                    <!--Change the  URL here if working on an absolute domain-->
                    <li><a href="../"><span class="mega-octicon octicon-terminal" style="margin-right: 6px;"></span>drew.</a><a href="http://kerrigan.io"><span style="margin-right: 6px;"></span>kerrigan.io</a></li>
                    <li><a href="../cv"><span class="mega-octicon octicon-person" style="margin-right: 6px;"></span>About</a></li>
                </ul>
            </header>
        </div>

        <div class="container">
            <p class="meta">November  5, 2014 by by name: "Drew Kerrigan"</p>

<div class="post">
    <p>This post is heavily influenced by <a href="https://github.com/clr" class="uri">https://github.com/clr</a> and his repository found here: <a href="https://github.com/clr/massive_distributed_sorted_set" class="uri">https://github.com/clr/massive_distributed_sorted_set</a></p>
<h1 id="the-problem">The Problem</h1>
<p>Consider the following use-case: A video game backend needs to track high scores for every user and display a leaderboard for those users. There are two main flavors of this problem that impact the resulting solution.</p>
<ol style="list-style-type: decimal">
<li>Display only the top 10 scores of all time</li>
<li>Display a user’s overall ranking as well as arbitrary pagination of the entire list</li>
</ol>
<h1 id="solution-1-display-only-the-top-10-scores-of-all-time">Solution 1: Display only the top 10 scores of all time</h1>
<p>This problem turns out to be fairly easy with map and set data structures like Riak’s: <a href="http://docs.basho.com/riak/latest/theory/concepts/crdts/#Riak-s-Five-Data-Types" class="uri">http://docs.basho.com/riak/latest/theory/concepts/crdts/#Riak-s-Five-Data-Types</a>.</p>
<h2 id="data-structures">Data Structures</h2>
<p>The map including a nested set might look something like this for a populated top 10 set:</p>
<p>Key: <code>game_top_10</code>, Value:</p>
<pre><code>{
  &quot;lowest_score&quot;: 90
  &quot;scores&quot;: [
    {&quot;user&quot;: &quot;vader&quot;, &quot;score&quot;: 99},
    {&quot;user&quot;: &quot;yoda&quot;, &quot;score&quot;: 98},
    {&quot;user&quot;: &quot;boba&quot;, &quot;score&quot;: 97},
    {&quot;user&quot;: &quot;luke&quot;, &quot;score&quot;: 96},
    {&quot;user&quot;: &quot;leia&quot;, &quot;score&quot;: 95},
    {&quot;user&quot;: &quot;palpatiner&quot;, &quot;score&quot;: 94},
    {&quot;user&quot;: &quot;obi-wan&quot;, &quot;score&quot;: 93},
    {&quot;user&quot;: &quot;jabba&quot;, &quot;score&quot;: 92},
    {&quot;user&quot;: &quot;r2-d2&quot;, &quot;score&quot;: 91},
    {&quot;user&quot;: &quot;chewbacca&quot;, &quot;score&quot;: 90}
  ]
}</code></pre>
<h2 id="algorithms">Algorithms</h2>
<p>The pseudo code for accepting a new score might look like this:</p>
<pre><code>update_score(Game, User, Score) -&gt;
  CurrentScores = get(Game ++ &quot;_top_10&quot;),
  LowestScore = get_lowest_score_from_map(CurrentScores),

  if
    Score &gt; LowestScore -&gt;
      NewScores = remove_lowest_score_and_add_new_score(CurrentScores, User, Score),
      put(Game ++ &quot;_top_10&quot;, NewScores);
    true -&gt;
      false
  end.</code></pre>
<p>Given our existing top 10 score list above, if we were to call update_score like so:</p>
<pre><code>update_score(&quot;game&quot;, &quot;han&quot;, 100).</code></pre>
<p>The resulting value for <code>game_top_10</code> in our datastore would look like this:</p>
<pre><code>{
  &quot;lowest_score&quot;: 91
  &quot;scores&quot;: [
    {&quot;user&quot;: &quot;han&quot;, &quot;score&quot;: 100},
    ...
    {&quot;user&quot;: &quot;r2-d2&quot;, &quot;score&quot;: 91}
  ]
}</code></pre>
<p>Because it may be possible to have multiple actors updating the top 10 scores concurrently, we need to have logic on read to ensure the following steps happen:</p>
<ul>
<li>Sort the list of scores in memory</li>
<li>If there are more than 10 entries in the set:</li>
<li>remove the lowest scores so that 10 remain</li>
<li>update the lowest_score entry and save the value</li>
</ul>
<h1 id="solution-2-display-a-users-overall-ranking-as-well-as-arbitrary-pagination-of-the-entire-list">Solution 2: Display a user’s overall ranking as well as arbitrary pagination of the entire list</h1>
<p>The solution to this problem is a little more tricky when we take into account the possibility of millions of users, or even billions or trillions of individual scores that need to be tracked over the lifetime of a game.</p>
<p>The above solution can be reused to scale the number of scores to much higher volumes. We’ll call a single set of scores (like the one above) an <code>entry_set</code>. In order to keep and make sense of multiple <code>entry_sets</code>, a <code>manifest</code> is required to keep track of the <code>entry_set</code> ids.</p>
<h2 id="data-structures-1">Data Structures</h2>
<p>Let’s start with an <code>entry_set</code> of 1000 scores:</p>
<p>Key: <code>game_entry_set_&lt;arbitrary_guid_1&gt;</code>, Value:</p>
<pre><code>[
  {&quot;user&quot;: &quot;han&quot;, &quot;score&quot;: 1000000},
  ...
  {&quot;user&quot;: &quot;r2-d2&quot;, &quot;score&quot;: 999000}
]</code></pre>
<p>Now the interesting part, the <code>manifest</code> which keeps track of multiple <code>entry_sets</code>:</p>
<p>Key: <code>game_manifest</code>, Value:</p>
<pre><code>{
  &quot;lowest_score&quot;: 100
  &quot;entry_sets&quot;: [
    {&quot;entry_set_id&quot;: &quot;game_entry_set_&lt;arbitrary_guid_1&gt;&quot;, &quot;length&quot;: 1000, &quot;lowest_score&quot;: 999000},
    {&quot;entry_set_id&quot;: &quot;game_entry_set_&lt;arbitrary_guid_2&gt;&quot;, &quot;length&quot;: 1000, &quot;lowest_score&quot;: 998000},
    ...
    {&quot;entry_set_id&quot;: &quot;game_entry_set_&lt;arbitrary_guid_1000&gt;&quot;, &quot;length&quot;: 400, lowest_score&quot;: 100}
  ]
}</code></pre>
<p>Using these data structures, we are storing 1000 <code>entry_sets</code> in our <code>manifest</code>, and 1000 individual scores and usernames in each <code>entry_set</code>. The limit of 1000 is somewhat arbitrary, but most of the time, you wouldn’t want to sort an unordered set of more than that many individual entries for performance reasons. With a set up like this, you could store up to 1 million individual scores in sorted order without the use of an external index.</p>
<h2 id="algorithms-1">Algorithms</h2>
<h3 id="writing-a-new-score">Writing a new score</h3>
<p>The pseudo code for adding a new score to the overall list then looks something like this:</p>
<pre><code># Get the corresponding `entry_set` for a given score, and add the new score to that `entry_set`
add_score(Game, User, Score) -&gt;
  CurrentManifest = get(Game ++ &quot;_manifest&quot;),
  SortedEntrySetMetadata = get_sorted_entry_set_metadata_from_manifest(CurrentManifest),
  EntrySetId = find_entry_set_id_for_score(SortedEntrySetMetadata, Score, &quot;&quot;),

  EntrySet = get(EntrySetId),

  NewEntrySet = append_score_to_entry_set(EntrySet, User, Score),
  put(EntrySetId, NewEntrySet).

# Iterate over a sorted set of metadata to find an appropriate `entry_set` id for a score
find_entry_set_id_for_score([], _) -&gt;
  {error, need_to_create_new_entry_set};

find_entry_set_id_for_score([Metadata | RestOfMetadata], Score) -&gt;
  LowestScore = get_lowest_score_from_metadata(Metadata),
  if
    Score &gt; LowestScore -&gt;
      EntrySetId = get_entry_set_id_from_metadata(Metadata),
      # Exit recursion and return the found EntrySetId
      EntrySetId;
    true -&gt;
      find_entry_set_id_for_score(RestOfMetadata, Score)
  end.</code></pre>
<p>In plain english, the goal of the above code reads like so:</p>
<ul>
<li>Get the current <code>manifest</code> which contains a list of all <code>entry_sets</code> as well as the lowest scores in each <code>entry_set</code></li>
<li>Sort the list of <code>entry_sets</code></li>
<li>Iterate over the <code>entry_sets</code> until we find one with a score lower than the one that we want to store</li>
<li>Append the new score to that <code>entry_set</code> and store it in the datastore</li>
<li>If the resulting <code>entry_set</code> exceeds the limit of 1000 scores:</li>
<li>Divide the <code>entry_set</code> into two separate <code>entry_sets</code></li>
<li>Delete the old one</li>
<li>Update the <code>manifest</code> by removing the old <code>entry_set</code> metadata and include the two ones</li>
</ul>
<h3 id="reading-the-top-10-scores">Reading the top 10 scores</h3>
<p>In order to read an arbitrary number of scores from an arbitrary position in the total set of scores, follow these steps:</p>
<ul>
<li>Get the current <code>manifest</code> which contains a list of all <code>entry_sets</code> as well as the length of each <code>entry_set</code></li>
<li>Sort the list of <code>entry_sets</code></li>
<li>Iterate over the <code>entry_sets</code> while adding up the length of each <code>entry_set</code> until the <code>entry_set</code> at the given offset is found</li>
<li>Fetch the <code>entry_set</code> at the correct offset, sort the list of scores found in the <code>entry_set</code></li>
<li>Return the number of desired scores in sorted order from the exact offset provided</li>
<li>It is possible that the number of requested scores spans multiple <code>entry_sets</code> - in this case more than one <code>entry_set</code> would need to be fetched to complete the query results given back to the user</li>
</ul>
<h1 id="solution-2a-what-about-billions-of-scores">Solution 2a: What about billions of scores?</h1>
<p>Solution 2 defined above works in theory for up to 1 million scores given our constraint of 1000 <code>entry_sets</code> per <code>manifest</code> and 1000 scores per <code>entry_set</code>. To go beyond that limit, it is simply a matter of adding additional layers of <code>manifests</code>. Here are a few example data structures for 1 billion total scores:</p>
<h2 id="data-structures-2">Data Structures</h2>
<h3 id="entry-set">Entry Set</h3>
<p>Key: <code>game_entry_set_&lt;arbitrary_guid_1&gt;</code>, Value:</p>
<pre><code>[
  {&quot;user&quot;: &quot;han&quot;, &quot;score&quot;: 100000},
  ...
  {&quot;user&quot;: &quot;r2-d2&quot;, &quot;score&quot;: 999000}
]</code></pre>
<h3 id="manifest">Manifest</h3>
<p>Key: <code>game_manifest_&lt;arbitrary_guid_1&gt;</code>, Value:</p>
<pre><code>{
  &quot;lowest_score&quot;: 100
  &quot;entry_sets&quot;: [
    {&quot;entry_set_id&quot;: &quot;game_entry_set_&lt;arbitrary_guid_1&gt;&quot;, &quot;length&quot;: 1000, &quot;lowest_score&quot;: 999000},
    {&quot;entry_set_id&quot;: &quot;game_entry_set_&lt;arbitrary_guid_2&gt;&quot;, &quot;length&quot;: 1000, &quot;lowest_score&quot;: 998000},
    ...
    {&quot;entry_set_id&quot;: &quot;game_entry_set_&lt;arbitrary_guid_1000&gt;&quot;, &quot;length&quot;: 400, lowest_score&quot;: 100}
  ]
}</code></pre>
<h3 id="manifest-of-manifests">Manifest of Manifests</h3>
<p>Key: <code>game_master_mainfest</code>, Value:</p>
<pre><code>{
  &quot;lowest_score&quot;: 100
  &quot;manifests&quot;: [
    {&quot;manifest_id&quot;: &quot;game_manifest_&lt;arbitrary_guid_1&gt;&quot;, &quot;length&quot;: 1000, &quot;lowest_score&quot;: 999000000},
    {&quot;manifest_id&quot;: &quot;game_manifest_&lt;arbitrary_guid_2&gt;&quot;, &quot;length&quot;: 1000, &quot;lowest_score&quot;: 999800000},
    ...
    {&quot;manifest_id&quot;: &quot;game_manifest_&lt;arbitrary_guid_1000&gt;&quot;, &quot;length&quot;: 10, lowest_score&quot;: 100}
  ]
}</code></pre>
<h2 id="algorithms-2">Algorithms</h2>
<p>The method of storing and retrieving scores for multiple layers of <code>manifests</code> is essentially the same as solution 2 above with additional recursion once the top level <code>manifests</code> are located.</p>
<p>Each additional layer of <code>manifests</code> added has an impact of sorting an additional 1000 members of an unordered set, as well as an additional read from the datastore.</p>
<p>In solution 2a with a single <code>master_manifest</code> of <code>manifests</code>, the process to store new score at a high level looks like this:</p>
<ul>
<li>Fetch and sort <code>master_manifest</code> of <code>manifests</code></li>
<li>Iterate over each <code>manifest</code> until the one that the new score belongs to is found using the <code>lowest_score</code> recorded for each <code>manifest</code></li>
<li>Fetch and sort <code>manifest</code> of <code>entry_sets</code></li>
<li>Iterate over each <code>entry_set</code> until the one that the new score belongs to is found using the <code>lowest_score</code> recorded for each <code>entry_set</code></li>
<li>Fetch and append the new score to that <code>entry_set</code></li>
<li>If the number of scores in the <code>entry_set</code> exceeds 1000, split it into two <code>entry_sets</code> and update the <code>manifest</code>
<ul>
<li>If the number of <code>entry_sets</code> in the <code>manifest</code> exeeds 1000, split it into two <code>manifests</code> and update the <code>master_manifest</code></li>
</ul></li>
</ul>
<h1 id="notes">Notes</h1>
<ul>
<li><p>The above data structures and algorithms make certain assumptions about the datastore being used. The sets and maps described above are pseudo-data representations of CRDTs. A similar solution is possible without the use of CRDTs, but the solution then becomes constrained with the need for serialized writes in order to make sure that no data is lost when updating <code>manifests</code> or <code>entry_sets</code>. Concurrent reads should still be possible without CRDTs.</p></li>
<li><p>Riak 2.0 introduced Registers, Sets, Counters, and Maps implemented as CRDTs on the server side which make the implementation of solutions such as these much easier. Find out more at <a href="http://docs.basho.com" class="uri">http://docs.basho.com</a> and <a href="http://docs.basho.com/riak/latest/theory/concepts/crdts/#Riak-s-Five-Data-Types" class="uri">http://docs.basho.com/riak/latest/theory/concepts/crdts/#Riak-s-Five-Data-Types</a>.</p></li>
<li><p>One limitation to keep in mind specifically with Riak 2.0’s Datatypes is that a single map/set object should not exceed 100k of raw data. Optimizing the contents of score, <code>entry_set</code>, and <code>manifest</code> metdata should easily allow for the suggested 1000 members per set.</p></li>
<li><p>An example proof of concept of Solution 2 without the use of Riak’s CRDT Datatypes can be found here: <a href="https://github.com/clr/massive_distributed_sorted_set" class="uri">https://github.com/clr/massive_distributed_sorted_set</a>. Please note that it expects serialized writes, and requires an additional data structure called a <code>transaction_log</code> to keep track of modified <code>manifests</code>.</p></li>
</ul>
</div>

        </div>
    </body>

    <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
         (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

     ga('create', 'UA-57872143-1', 'auto');
     ga('send', 'pageview');

    </script>
</html>
